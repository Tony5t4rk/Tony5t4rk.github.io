<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

  <!-- font-family -->
  <link href="https://fonts.googleapis.com/css?family=Pacifico" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">

  <!-- Highlight.js -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/solarized-light.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- jquery -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.slim.min.js"></script>

  <title>Tony5t4rk&#39;s Blog</title>
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <link rel="stylesheet" href="/css/sally.css">
	
    <link rel="shortcut icon" href="/img/favicon.png">
  
</head>

  <body>
    <header id="header">
  <div id="site-title">
    <a href="http://tony5t4rk.github.io" id="logo">
      <img id="site-logo" src="/img/blog-logo.png">
      <p>Tony5t4rk&#39;s Blog</p>
    </a>
  </div>
  <nav id="navbar">
    <ul id="menu">
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">
            Archives
          </a>
        </li>
      
    </ul>
  </nav>
</header>
    <div id="side">
  <div id="search">
    <img id="search-logo" src="/img/search.png">
    <input type="text" id="search-input" placeholder=" search">
  </div>

  <div id="author-info">
    <img id="info-logo" src="/img/avatar.png">
    <p id="info-author">Tony5t4rk</p>
    <div id="social">
      
        <div class="social-item">
          <a href="https://github.com/Tony5t4rk" class="social-item-link">
            <img class="social-img" src="/img/Github.png">
            <p class="social-item-name">Github</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="https://www.zhihu.com/people/ru-guo-you-meng-49" class="social-item-link">
            <img class="social-img" src="/img/知乎.png">
            <p class="social-item-name">知乎</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="mailto:tony5t4rk@qq.com" class="social-item-link">
            <img class="social-img" src="/img/Email.png">
            <p class="social-item-name">Email</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="https://blog.csdn.net/Tony5t4rk" class="social-item-link">
            <img class="social-img" src="/img/CSDN.png">
            <p class="social-item-name">CSDN</p>
          </a>
        </div>
      
    </div>
  </div>

  <div id="friend">
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/henu_jizhideqingwa" class="friend-item-link">
          <p class="friend-item-name">jizhideqingwa</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/henuyh" class="friend-item-link">
          <p class="friend-item-name">yh</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://www.lusquare.top/" class="friend-item-link">
          <p class="friend-item-name">lusquare</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/ordinarv" class="friend-item-link">
          <p class="friend-item-name">ordinarv</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://raindecloud.top/" class="friend-item-link">
          <p class="friend-item-name">raindecloud</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://47.106.254.106/" class="friend-item-link">
          <p class="friend-item-name">cyt</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://euzmin.github.io/" class="friend-item-link">
          <p class="friend-item-name">zmin</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/qq_41199327" class="friend-item-link">
          <p class="friend-item-name">mmc</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/qq_40482358" class="friend-item-link">
          <p class="friend-item-name">wxj</p>
        </a>
      </div>
    
  </div>

  <div id="site-info">
  </div>
</div>

    <main id="main">
      <article id="post">
  <div class="post-title">
    <h2 class="title">AYITOJ ROUND #3</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2018-12-18</span>
  </div>
  <div class="post-content">
    <h1 id="A-TAT"><a href="#A-TAT" class="headerlink" title="A.TAT"></a>A.TAT</h1><h2 id="Descriptiion"><a href="#Descriptiion" class="headerlink" title="Descriptiion:"></a>Descriptiion:</h2><p>给定一个字符串s, 问”TAT”是否为s的子串</p>
<p>一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S 中出现了。比如，“中出”是“我们中出了一个叛徒”的子串。</p>
<p>注意子串和子序列是不同的：“苹机”是“苹果手机”的子序列，而不是子串。</p>
<p>前缀和后缀是两种特殊的子串：一个前缀在原串的开始位置出现，而一个后缀在原串的末端出现。</p>
<p>例如，“苹果手机”的所有子串是：“”（空串），“苹”，“果”，“手”，“机”，“苹果”，“果手”，“手机”，“苹果手”，“果手机”，“苹果手机”。</p>
<p>以上摘自维基百科~</p>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h2><p>仅一行, 一个字符串s</p>
<p>保证该字符串中仅含有大写字母</p>
<p>数据范围</p>
<p>$|s|$ &lt;= $100000$</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h2><p>仅一行, 一个字符串”Yes”表示”TAT”是s的子串, 否则输出”No”</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><pre><code>TATATAT
</code></pre><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><pre><code>Yes
</code></pre><h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><pre><code>TAAT
</code></pre><h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><pre><code>No
</code></pre><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.ayit.edu.cn/contest/6/problem/42" target="_blank" rel="noopener">题目链接</a></h3><p>直接用C++ STL的string.find!=string::npos就可以查找判断子串。</p>
<p>手写KMP也可。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(int argc, char *argv[]) {
    string Str;
    cin &gt;&gt; Str;
    if (Str.find(&quot;TAT&quot;) != string::npos) {
        printf(&quot;Yes\n&quot;);
    }
    else {
        printf(&quot;No\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="B-计算表达式"><a href="#B-计算表达式" class="headerlink" title="B.计算表达式"></a>B.计算表达式</h1><h2 id="Descriptiion-1"><a href="#Descriptiion-1" class="headerlink" title="Descriptiion:"></a>Descriptiion:</h2><p>给定一个形如 $a # b$ 的表达式</p>
<p>求这个表达式所代表的值</p>
<p>#可以为+(加),*(乘),^(幂)三种运算符的任意一种</p>
<p>由于结果可能很大, 你只需输出其对1000000007取膜的结果即可</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h2><p>第一行两个整数 $T$ 表示表达式的总数</p>
<p>接下来 $T$ 行每行一个表达式 $a$ # $b$</p>
<p>数据范围</p>
<p>$ 0 &lt; T &lt;= 10 $</p>
<p>$ 0 &lt;= a , b &lt;= 10^9$</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h2><p>共T行, 每行一个整数, 表示对应表达式所表示的值</p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3<br>1 + 1<br>2 * 2<br>2 ^ 3</p>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>2<br>4<br>8</p>
<h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://acm.ayit.edu.cn/contest/6/problem/43" target="_blank" rel="noopener">题目链接</a></h3><p>两个数的运算，幂运算写了个快速幂，不过最后好像没卡？</p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int mod = 1e9 + 7;

long long QuickMul(long long A, long long B) {
    long long Ans = 0;
    while (B) {
        if (B &amp; 1) {
            Ans = (Ans + A) % mod;
        }
        A = (A + A) % mod;
        B &gt;&gt;= 1;
    }
    return Ans;
}

long long QuickPow(long long A, long long B) {
    long long Ans = 1;
    while (B) {
        if (B &amp; 1) {
            Ans = QuickMul(Ans, A) % mod;
        }
        A = QuickMul(A, A) % mod;
        B &gt;&gt;= 1;
    }
    return Ans;
}

int main(int argc, char *argv[]) {
    long long A, B;
    char Op;
    int T;
    cin &gt;&gt; T;
    while (T--) {
        cin &gt;&gt; A &gt;&gt; Op &gt;&gt; B;
        if (Op == &#39;+&#39;) {
            cout &lt;&lt; (A + B) % mod &lt;&lt; endl;
        }
        else if (Op == &#39;*&#39;) {
            cout &lt;&lt; QuickMul(A, B) &lt;&lt; endl;
        }
        else if (Op == &#39;^&#39;) {
            cout &lt;&lt; QuickPow(A, B) &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
<h1 id="C-飞行棋"><a href="#C-飞行棋" class="headerlink" title="C.飞行棋"></a>C.飞行棋</h1><h2 id="Descriptiion-2"><a href="#Descriptiion-2" class="headerlink" title="Descriptiion:"></a>Descriptiion:</h2><p>飞行棋是一款十分有趣的游戏</p>
<p>不过在这里, 我们只考虑如下的简化重制版本:</p>
<ol>
<li><p>棋盘为一个数轴 $(-∞,+∞)$</p>
</li>
<li><p>如果玩家当前在 $x$, 那么下一步他可以走到 $x-1$ 或 $x+1$</p>
</li>
<li><p>特殊地, 在某些位置 $a_i$ 上, 玩家可以从当前位置直接一步跳到另一个位置 $b_i$ 上</p>
</li>
<li><p>玩家一开始在 $S$, 请问玩家走到 $T$ 至少需要走多少步?</p>
</li>
</ol>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input:"></a>Input:</h2><p>第一行三个整数 $n,S,T$ 分别表示可以直接跳跃的点数和玩家的起点与终点</p>
<p>接下来 $n$ 行每行2个整数 $a_i ,b_i$ 表示从 $a_i$ 可以直接一步跳到 $b_i$</p>
<p>数据范围</p>
<p>$ 0 &lt;= n &lt;= 2 * 10^{5} $</p>
<p>$ 0 &lt;= |a_i| , |b_i| , |S| , |T| &lt;= 10^{18}$</p>
<p>保证 $a_i \not= a_j (i \not= j), a_i \not= b_i$</p>
<p>友情提示: 请注意坐标可以为负数!</p>
<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output:"></a>Output:</h2><p>仅一行, 一个整数, 表示玩家从 $S$ 走到 $T$ 最少需要的步数</p>
<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3 1 20<br>1 11<br>10 5<br>6 20</p>
<h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>5</p>
<h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a><a href="http://acm.ayit.edu.cn/contest/6/problem/44" target="_blank" rel="noopener">题目链接</a></h3><p>最开始没想到是个图论题，一直在Bfs搜索，不过数据有点大，正解是建图跑最短路。</p>
<p>只有跳跃点有用，先把所有点离散化，之后把每个跳跃点与左右最近的跳跃点建权值为其距离的边，把跳跃两点建权值为1的边用Dijkstra求起点到终点的最短路即可。</p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 2e5 + 5;

struct Edge {
    long long V, Dis, Next;
};

Edge edges[maxn &lt;&lt; 4];
int Head[maxn &lt;&lt; 1];
int Tot;

void Init() {
    Tot = 0;
    memset(Head, -1, sizeof(Head));
}

void AddEdge(int U, int V, long long Weight) {
    edges[Tot] = Edge {V, Weight, Head[U]};
    Head[U] = Tot++;
}

long long Dis[maxn &lt;&lt; 1];

struct Cmp {
    bool operator () (const int &amp;A, const int &amp;B) {
        return Dis[A] &gt; Dis[B];
    }
};

long long Dijkstra(int Start, int End) {
    priority_queue&lt;int, vector&lt;int&gt;, Cmp&gt; Que;
    memset(Dis, 0x3f, sizeof(Dis));
    Dis[Start] = 0;
    Que.push(Start);
    while (!Que.empty()) {
        int Cur = Que.top(); Que.pop();
        if (Cur == End) {
            return Dis[End];
        }
        for (int i = Head[Cur]; ~i; i = edges[i].Next) {
            if (Dis[edges[i].V] &gt; Dis[Cur] + edges[i].Dis) {
                Dis[edges[i].V] = Dis[Cur] + edges[i].Dis;
                Que.push(edges[i].V);
            }
        }
    }
    return -1 * 1LL;
}

long long N, S, T;
long long U[maxn], V[maxn];
long long numbers[maxn &lt;&lt; 1];
long long Cnt, Size;

int Disperse(long long X) {
    return lower_bound(numbers, numbers + Size, X) - numbers + 1;
}

int main(int argc, char *argv[]) {
    Init();
    scanf(&quot;%lld%lld%lld&quot;, &amp;N, &amp;S, &amp;T);
    Cnt = 0;
    numbers[Cnt++] = S; numbers[Cnt++] = T;
    for (long long i = 1; i &lt;= N; ++i) {
        scanf(&quot;%lld%lld&quot;, &amp;U[i], &amp;V[i]);
        numbers[Cnt++] = U[i]; numbers[Cnt++] = V[i];
    }
    sort(numbers, numbers + Cnt);
    Size = unique(numbers, numbers + Cnt) - numbers;
    for (int i = 0; i &lt; Size - 1; ++i) {
        AddEdge(i + 1, i + 2, numbers[i + 1] - numbers[i]);
        AddEdge(i + 2, i + 1, numbers[i + 1] - numbers[i]);
    }
    for (int i = 1; i &lt;= N; ++i) {
        AddEdge(Disperse(U[i]), Disperse(V[i]), 1);
    }
    printf(&quot;%lld\n&quot;, Dijkstra(Disperse(S), Disperse(T)));
    return 0;
}
</code></pre>
<h1 id="E-求和问题"><a href="#E-求和问题" class="headerlink" title="E.求和问题"></a>E.求和问题</h1><h2 id="Descriptiion-3"><a href="#Descriptiion-3" class="headerlink" title="Descriptiion:"></a>Descriptiion:</h2><p>你现在有一个数组 $A$</p>
<p>我们定义如下的两种操作:</p>
<ol>
<li>修改: 形如 $0$ $l$ $r$ ,效果为对所有 $ l &lt;= i &lt;=r $ 执行 $ A_i += (i-l+1) $</li>
</ol>
<p>直观地说就是$A_l+=1, A_{l+1}+=2, A_{l+2}+=3 \ … \ A_{r}+=r-l+1$ 这个样子</p>
<ol start="2">
<li>查询: 形如 $1$ $l$ $r$ , 要求输出此时的 $ \sum_{i=l}^{r}A_i $ 的值 </li>
</ol>
<p>一开始当然整个数组都是0啦</p>
<h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input:"></a>Input:</h2><p>第一行一个整数Q表示操作总数</p>
<p>接下来Q行, 每行一个操作(格式参考题目描述)</p>
<h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output:"></a>Output:</h2><p>对于每个查询, 输出一行, 表示此时的 $ \sum_{i=l}^{r}A_i $ 的值</p>
<h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3<br>0 1 2<br>0 3 4<br>1 1 4</p>
<h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>6</p>
<h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a><a href="http://acm.ayit.edu.cn/contest/6/problem/46" target="_blank" rel="noopener">题目链接</a></h3><p>这个题用两个Lazy惰性数组标记进行等差数列的相加，Tql……</p>
<p>Lazy1：当前区间上的未下传的要加的值</p>
<p>Lazy2：当前区间上的未下穿的等差数列的数量</p>
<p>Lazy1和普通线段树的Lazy一样，而Lazy2则改为了等差数列的下传数量</p>
<p>Example:若要加{1,2,3,4}，则把它拆为{1,2},{3,4}，其中{1,2}传给其左子树的Lazy2(一份等差数列)，而{3,4}拆开为{1,2}和{2,2}，其中{2,2}传给其右子树的Lazy1，{1,2}传给其右子树的Lazy2(一份等差数列)</p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const long long maxn = 1e5 + 5;

struct Node {
    long long Left, Right;
    long long Lazy1, Lazy2;
    long long Sum;
};

Node SegmentTree[maxn &lt;&lt; 2];

void PushDown(long long Root) {
    if (SegmentTree[Root].Lazy1) {
        SegmentTree[Root].Sum += SegmentTree[Root].Lazy1 * (SegmentTree[Root].Right - SegmentTree[Root].Left + 1);
        if (SegmentTree[Root].Left &lt; SegmentTree[Root].Right) {
            SegmentTree[Root &lt;&lt; 1].Lazy1 += SegmentTree[Root].Lazy1;
            SegmentTree[Root &lt;&lt; 1 | 1].Lazy1 += SegmentTree[Root].Lazy1;
        }
        SegmentTree[Root].Lazy1 = 0;
    }
    if (SegmentTree[Root].Lazy2) {
        SegmentTree[Root].Sum += SegmentTree[Root].Lazy2 * (SegmentTree[Root].Right - SegmentTree[Root].Left + 1) * (SegmentTree[Root].Right - SegmentTree[Root].Left + 2) / 2;
        if (SegmentTree[Root].Left &lt; SegmentTree[Root].Right) {
            SegmentTree[Root &lt;&lt; 1].Lazy2 += SegmentTree[Root].Lazy2;
            SegmentTree[Root &lt;&lt; 1 | 1].Lazy2 += SegmentTree[Root].Lazy2;
            SegmentTree[Root &lt;&lt; 1 | 1].Lazy1 += SegmentTree[Root].Lazy2 * (SegmentTree[Root &lt;&lt; 1].Right - SegmentTree[Root &lt;&lt; 1].Left + 1);
        }
        SegmentTree[Root].Lazy2 = 0;
    }
}

void PushUp(long long Root) {
    PushDown(Root &lt;&lt; 1); PushDown(Root &lt;&lt; 1 | 1);
    SegmentTree[Root].Sum = SegmentTree[Root &lt;&lt; 1].Sum + SegmentTree[Root &lt;&lt; 1 | 1].Sum;
}

void Build(long long Left, long long Right, long long Root) {
    SegmentTree[Root] = Node {Left, Right, 0, 0, 0};
    if (Left == Right) {
        return;
    }
    long long Mid = (Left + Right) &gt;&gt; 1;
    Build(Left, Mid, Root &lt;&lt; 1);
    Build(Mid + 1, Right, Root &lt;&lt; 1 | 1);
}

void IntervalUpdate(long long Left, long long Right, long long Root) {
    if (SegmentTree[Root].Left &gt;= Left &amp;&amp; SegmentTree[Root].Right &lt;= Right) {
        SegmentTree[Root].Lazy1 += SegmentTree[Root].Left - Left;
        SegmentTree[Root].Lazy2++;
        return;
    }
    long long Mid = (SegmentTree[Root].Left + SegmentTree[Root].Right) &gt;&gt; 1;
    if (Left &lt;= Mid) {
        PushDown(Root);
        IntervalUpdate(Left, Right, Root &lt;&lt; 1);
    }
    if (Right &gt; Mid) {
        PushDown(Root);
        IntervalUpdate(Left, Right, Root &lt;&lt; 1 | 1);
    }
    if (SegmentTree[Root].Left &lt; SegmentTree[Root].Right) {
        PushUp(Root);
    }
}

long long Query(long long Left, long long Right, long long Root) {
    long long Ans = 0;
    PushDown(Root);
    if (SegmentTree[Root].Left &gt;= Left &amp;&amp; SegmentTree[Root].Right &lt;= Right) {
        return SegmentTree[Root].Sum;
    }
    long long Mid = (SegmentTree[Root].Left + SegmentTree[Root].Right) &gt;&gt; 1;
    if (Left &lt;= Mid) {
        Ans += Query(Left, Right, Root &lt;&lt; 1);
    }
    if (Right &gt; Mid) {
        Ans += Query(Left, Right, Root &lt;&lt; 1 | 1);
    }
    return Ans;
}

long long T;
long long Op, Left, Right;
const long long Max = 1e5;

int main(int argc, char *argv[]) {
    Build(1, Max, 1);
    scanf(&quot;%lld&quot;, &amp;T);
    for (long long Case = 1; Case &lt;= T; ++Case) {
        scanf(&quot;%lld%lld%lld&quot;, &amp;Op, &amp;Left, &amp;Right);
        if (Op == 0) {
            IntervalUpdate(Left, Right, 1);
        }
        else {
            printf(&quot;%lld\n&quot;, Query(Left, Right, 1));
        }
    }
    return 0;
}
</code></pre>
<h1 id="F-斐波那契数列"><a href="#F-斐波那契数列" class="headerlink" title="F.斐波那契数列"></a>F.斐波那契数列</h1><h2 id="Descriptiion-4"><a href="#Descriptiion-4" class="headerlink" title="Descriptiion:"></a>Descriptiion:</h2><p>没错又是大家熟悉的斐波那契数列~</p>
<p>什么你不知道? 没关系我们来给你定义: </p>
<p>$F_1=1, F_2=1, F_i=F_{i-1}+F_{i-2}(i&gt;2)$</p>
<p>然后你需要求出 $ \sum_{i=l}^{r} F_i$ 的值, $l,r$ 会由题目给出</p>
<p>由于答案可能很大, 你只需答案输出对100000000<em>9</em> 取膜的结果即可~</p>
<h2 id="Input-4"><a href="#Input-4" class="headerlink" title="Input:"></a>Input:</h2><p>第一行一个整数T表示询问次数</p>
<p>接下来T行每行两个整数 $l,r$ 表示询问 $ \sum_{i=l}^{r} F_i$ 的值</p>
<h2 id="Output-4"><a href="#Output-4" class="headerlink" title="Output:"></a>Output:</h2><p>共T行, 每行一个整数表示对应的询问的答案</p>
<h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3<br>1 2<br>3 5<br>233 456</p>
<h2 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>2<br>10<br>623800639</p>
<h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a><a href="http://acm.ayit.edu.cn/contest/6/problem/47" target="_blank" rel="noopener">题目链接</a></h3><p>毒瘤题石锤了……！</p>
<p>蒟蒻只能用矩阵快速幂+斐波那契数列前n项和公式+读写挂拿到200分(4个任务点)。</p>
<h2 id="200分-未AC-代码"><a href="#200分-未AC-代码" class="headerlink" title="200分(未AC)代码:"></a>200分(未AC)代码:</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int mod = 1e9 + 9;

namespace FastIO {
    const int MX = 4e7;
    char buf[MX];
    int c, sz;
    void begin() {
        c = 0;
        sz = fread(buf, 1, MX, stdin);
    }
    template &lt;class T&gt;
    inline bool read(T &amp;t) {
        while (c &lt; sz &amp;&amp; buf[c] != &#39;-&#39; &amp;&amp; (buf[c] &lt; &#39;0&#39; || buf[c] &gt; &#39;9&#39;)) {
            c++;
        }
        if (c &gt;= sz) {
            return false;
        }
        bool flag = 0;
        if (buf[c] == &#39;-&#39;) {
            flag = 1;
            c++;
        }
        for (t = 0; c &lt; sz &amp;&amp; &#39;0&#39; &lt;= buf[c] &amp;&amp; buf[c] &lt;= &#39;9&#39;; ++c) {
            t = t * 10 + buf[c] - &#39;0&#39;;
        }
        if (flag) {
            t = -t;
        }
        return true;
    }
};

struct Matrix {
    unsigned long long Mat[2][2];
    Matrix() {}
    Matrix operator * (Matrix const &amp;A) const {
        Matrix Res;
        memset(Res.Mat, 0, sizeof(Res.Mat));
        for (int i = 0; i &lt; 2; ++i) {
            for (int j = 0; j &lt; 2; ++j) {
                for (int k = 0; k &lt; 2; ++k) {
                    Res.Mat[i][j] = (Res.Mat[i][j] + Mat[i][k] * A.Mat[k][j] % mod) % mod;
                }
            }
        }
        return Res;
    }
};

Matrix operator ^ (Matrix Base, long long K) {
    Matrix Res;
    memset(Res.Mat, 0, sizeof(Res.Mat));
    Res.Mat[0][0] = Res.Mat[1][1] = 1;
    while (K) {
        if (K &amp; 1) {
            Res = Res * Base;
        }
        Base = Base * Base;
        K &gt;&gt;= 1;
    }
    return Res;
}

unsigned long long Fib(unsigned long long X) {
    Matrix Base;
    Base.Mat[0][0] = Base.Mat[1][0] = Base.Mat[0][1] = 1;
    Base.Mat[1][1] = 0;
    return (Base ^ X).Mat[0][1];
}

unsigned long long Sum(unsigned long long N) {
    return Fib(N + 2) - 1;
}

unsigned long long T;
unsigned long long Left, Right;
long long Ans;

int main(int argc, char *argv[]) {
    FastIO::begin();
    FastIO::read(T);
    for (unsigned long long Case = 1; Case &lt;= T; ++Case) {
        FastIO::read(Left); FastIO::read(Right);
        Ans = Sum(Right) - Sum(Left - 1);
        while (Ans &lt; 0) {
            Ans += mod;
        }
        printf(&quot;%lld\n&quot;, Ans);
    }
    return 0;
}
</code></pre>

  </div>
</article>
    </main>
    <footer id="footer">
  <p id="footer-info">
    <a href="https://hexo.io/zh-cn/" id="footer-hexo">Hexo</a>
    Theme
    <a href="" id="footer-theme">&hearts;Sally&hearts;</a>
    by
    <a href="https://tony5t4rk.github.io/" id="theme-author">Tony5t4rk</a>
  </p>
</footer>
  </body>
</html>