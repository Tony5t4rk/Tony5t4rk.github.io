<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

  <!-- font-family -->
  <link href="https://fonts.googleapis.com/css?family=Pacifico" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">

  <!-- Highlight.js -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/solarized-light.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- jquery -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.slim.min.js"></script>

  <title>Tony5t4rk&#39;s Blog</title>
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <link rel="stylesheet" href="/css/sally.css">
	
    <link rel="shortcut icon" href="/img/favicon.png">
  
</head>

  <body>
    <header id="header">
  <div id="site-title">
    <a href="http://tony5t4rk.github.io" id="logo">
      <img id="site-logo" src="/img/blog-logo.png">
      <p>Tony5t4rk&#39;s Blog</p>
    </a>
  </div>
  <nav id="navbar">
    <ul id="menu">
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">
            Archives
          </a>
        </li>
      
    </ul>
  </nav>
</header>
    <div id="side">
  <div id="search">
    <img id="search-logo" src="/img/search.png">
    <input type="text" id="search-input" placeholder=" search">
  </div>

  <div id="author-info">
    <img id="info-logo" src="/img/avatar.png">
    <p id="info-author">Tony5t4rk</p>
    <div id="social">
      
        <div class="social-item">
          <a href="https://github.com/Tony5t4rk" class="social-item-link">
            <img class="social-img" src="/img/Github.png">
            <p class="social-item-name">Github</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="https://www.zhihu.com/people/ru-guo-you-meng-49" class="social-item-link">
            <img class="social-img" src="/img/知乎.png">
            <p class="social-item-name">知乎</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="mailto:tony5t4rk@qq.com" class="social-item-link">
            <img class="social-img" src="/img/Email.png">
            <p class="social-item-name">Email</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="https://blog.csdn.net/Tony5t4rk" class="social-item-link">
            <img class="social-img" src="/img/CSDN.png">
            <p class="social-item-name">CSDN</p>
          </a>
        </div>
      
    </div>
  </div>

  <div id="friend">
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/henu_jizhideqingwa" class="friend-item-link">
          <p class="friend-item-name">jizhideqingwa</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/henuyh" class="friend-item-link">
          <p class="friend-item-name">yh</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://www.lusquare.top/" class="friend-item-link">
          <p class="friend-item-name">lusquare</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/ordinarv" class="friend-item-link">
          <p class="friend-item-name">ordinarv</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://raindecloud.top/" class="friend-item-link">
          <p class="friend-item-name">raindecloud</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://47.106.254.106/" class="friend-item-link">
          <p class="friend-item-name">cyt</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://euzmin.github.io/" class="friend-item-link">
          <p class="friend-item-name">zmin</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/qq_41199327" class="friend-item-link">
          <p class="friend-item-name">mmc</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/qq_40482358" class="friend-item-link">
          <p class="friend-item-name">wxj</p>
        </a>
      </div>
    
  </div>

  <div id="site-info">
  </div>
</div>

    <main id="main">
      <article id="post">
  <div class="post-title">
    <h2 class="title">Technocup 2019 - Elimination Round 4</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2018-12-24</span>
  </div>
  <div class="post-content">
    <h1 id="A-Right-Left-Cipher"><a href="#A-Right-Left-Cipher" class="headerlink" title="A. Right-Left Cipher"></a>A. Right-Left Cipher</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Polycarp loves ciphers. He has invented his own cipher called Right-Left.<br>Right-Left cipher is used for strings. To encrypt the string $s=s_{1}s_{2} \dots s_{n}$ Polycarp uses the following algorithm:</p>
<ul>
<li>he writes down $s_1$,</li>
<li>he appends the current word with $s_2$ (i.e. writes down $s_2$ to the right of the current result),</li>
<li>he prepends the current word with $s_3$ (i.e. writes down $s_3$ to the left of the current result),</li>
<li>he appends the current word with $s_4$ (i.e. writes down $s_4$ to the right of the current result),</li>
<li>he prepends the current word with $s_5$ (i.e. writes down $s_5$ to the left of the current result),</li>
<li>and so on for each position until the end of $s$.</li>
</ul>
<p>For example, if $s$=”techno” the process is: “t” $\to$ “te” $\to$ “cte” $\to$ “cteh” $\to$ “ncteh” $\to$ “ncteho”. So the encrypted $s$=”techno” is “ncteho”.</p>
<p>Given string $t$ — the result of encryption of some string $s$. Your task is to decrypt it, i.e. find the string $s$.</p>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h2><p>The only line of the input contains $t$ — the result of encryption of some string $s$. It contains only lowercase Latin letters. The length of $t$ is between $1$ and $50$, inclusive.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h2><p>Print such string $s$ that after encryption it equals $t$.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>ncteho</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>techno</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>erfdcoeocs</p>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>codeforces</p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>z</p>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>z</p>
<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1085/problem/A" target="_blank" rel="noopener">题目链接</a></h3><p>将一个字符串左右依次放置重新排序，输出原始字符串。</p>
<p>左右依次取字符串压栈，最后从栈输出即可。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

string Str;
int Len;
int Left, Right;
stack&lt;char&gt; S;

int main(int argc, char *argv[]) {
    cin &gt;&gt; Str;
    Len = (int)Str.length();
    Left = 0, Right = Len - 1;
    if (Len &amp; 1) {
        S.push(Str[Left++]);
    }
    while (Left &lt; Right) {
        S.push(Str[Right--]);
        if (Right &lt; Left) {
            break;
        }
        S.push(Str[Left++]);
    }
    while (!S.empty()) {
        cout &lt;&lt; S.top();
        S.pop();
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h1 id="B-Div-Times-Mod"><a href="#B-Div-Times-Mod" class="headerlink" title="B. Div Times Mod"></a>B. Div Times Mod</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description:"></a>Description:</h2><p>Vasya likes to solve equations. Today he wants to solve $(x~\mathrm{div}~k) \cdot (x \bmod k) = n$, where $\mathrm{div}$ and $\mathrm{mod}$ stand for integer division and modulo operations (refer to the Notes below for exact definition). In this equation, $k$ and $n$ are positive integer parameters, and $x$ is a positive integer unknown. If there are several solutions, Vasya wants to find the smallest possible $x$. Can you help him?</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h2><p>The first line contains two integers $n$ and $k$ ($1 \leq n \leq 10^6$, $2 \leq k \leq 1000$).</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h2><p>Print a single integer $x$ — the smallest positive integer solution to $(x~\mathrm{div}~k) \cdot (x \bmod k) = n$. It is guaranteed that this equation has at least one positive integer solution.</p>
<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>6 3</p>
<h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>11</p>
<h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>1 2</p>
<h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>3</p>
<h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>4 6</p>
<h2 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>10</p>
<h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1085/problem/B" target="_blank" rel="noopener">题目链接</a></h3><p>寻找最小x使 $\lfloor \frac{x}{k} \rfloor \times (x \% k) = n$ 。</p>
<p>枚举数x%k（1~k），判断取最小值即可。</p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int INF = 0x3f3f3f3f;

int N, K;
int Ans;

int main(int argc, char *argv[]) {
    scanf(&quot;%d%d&quot;, &amp;N, &amp;K);
    Ans = INF;
    for (int i = 1; i &lt;= K; ++i) {
        if (N % i == 0) {
            int Temp = N / i;
            int X = Temp * K + i;
            if ((X / K) * (X % K) == N) {
                Ans = min(Ans, X);
            }
        }
    }
    printf(&quot;%d\n&quot;, Ans);
    return 0;
}
</code></pre>
<h1 id="C-Connect-Three"><a href="#C-Connect-Three" class="headerlink" title="C. Connect Three"></a>C. Connect Three</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description:"></a>Description:</h2><p>The Squareland national forest is divided into equal $1 \times 1$ square plots aligned with north-south and east-west directions. Each plot can be uniquely described by integer Cartesian coordinates $(x, y)$ of its south-west corner.<br>Three friends, Alice, Bob, and Charlie are going to buy three distinct plots of land $A, B, C$ in the forest. Initially, all plots in the forest (including the plots $A, B, C$) are covered by trees. The friends want to visit each other, so they want to clean some of the plots from trees. After cleaning, one should be able to reach any of the plots $A, B, C$ from any other one of those by moving through adjacent cleared plots. Two plots are adjacent if they share a side.</p>
<p><img src="http://codeforces.com/predownloaded/4b/55/4b55df51f3518920f5b5342fa3205599c82ebddd.png" alt=""></p>
<p>For example, $A=(0,0)$, $B=(1,1)$, $C=(2,2)$. The minimal number of plots to be cleared is $5$. One of the ways to do it is shown with the gray color. Of course, the friends don’t want to strain too much. Help them find out the smallest number of plots they need to clean from trees.</p>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input:"></a>Input:</h2><p>The first line contains two integers $x_A$ and $y_A$ — coordinates of the plot $A$ ($0 \leq x_A, y_A \leq 1000$). The following two lines describe coordinates $(x_B, y_B)$ and $(x_C, y_C)$ of plots $B$ and $C$ respectively in the same format ($0 \leq x_B, y_B, x_C, y_C \leq 1000$). It is guaranteed that all three plots are distinct.</p>
<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output:"></a>Output:</h2><p>On the first line print a single integer $k$ — the smallest number of plots needed to be cleaned from trees. The following $k$ lines should contain coordinates of all plots needed to be cleaned. All $k$ plots should be distinct. You can output the plots in any order.<br>If there are multiple solutions, print any of them.</p>
<h2 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>0 0<br>1 1<br>2 2</p>
<h2 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>5<br>0 0<br>1 0<br>1 1<br>1 2<br>2 2</p>
<h2 id="Sample-Input-7"><a href="#Sample-Input-7" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>0 0<br>2 0<br>1 1</p>
<h2 id="Sample-Output-7"><a href="#Sample-Output-7" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>4<br>0 0<br>1 0<br>1 1<br>2 0</p>
<h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint:"></a>Hint:</h2><p>The first example is shown on the picture in the legend.</p>
<p>The second example is illustrated with the following image:</p>
<p><img src="http://codeforces.com/predownloaded/55/37/55373f5a1cae2c977caf7f25f91ef14da25ed684.png" alt=""></p>
<h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1085/problem/C" target="_blank" rel="noopener">题目链接</a></h3><p>用最少的单元格打通三个单元格。</p>
<p>最左最右（或者也可以最上最下）的单元格往中间单元格找路径即可，去重相同单元格。</p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

struct Point {
    int X, Y;

    void Input() {
        scanf(&quot;%d%d&quot;, &amp;X, &amp;Y);
    }

    void Output() {
        printf(&quot;(%d,%d)\n&quot;, X, Y);
    }

    bool operator &lt; (const Point &amp;B) const {
        return X &lt; B.X;
    }
};

Point points[3];
int Ans;
int NX, NY;
set&lt;pair&lt;int, int&gt; &gt; S;

void Solve(int &amp;Origin, int Target, int Other, bool Flag) {
    if (Target &gt; Origin) {
        for (int i = Origin; i &lt;= Target; ++i) {
            if (Flag) {
                if(S.find(make_pair(i, Other)) == S.end()) {
                    S.insert(make_pair(i, Other));
                }
                Origin = i;
            }
            else {
                if (S.find(make_pair(Other, i)) == S.end()) {
                    S.insert(make_pair(Other, i));
                }
                Origin = i;
            }
        }
    }
    else {
        for (int i = Origin; i &gt;= Target; --i) {
            if (Flag) {
                if (S.find(make_pair(i, Other)) == S.end()) {
                    S.insert(make_pair(i, Other));
                }
                Origin = i;
            }
            else {
                if (S.find(make_pair(Other, i)) == S.end()) {
                    S.insert(make_pair(Other, i));
                }
                Origin = i;
            }
        }
    }
}

int main(int argc, char *argv[]) {
    for (int i = 0; i &lt; 3; ++i) {
        points[i].Input();
    }
    sort(points, points + 3);
    S.clear();
    Solve(points[0].X, points[1].X, points[0].Y, true);
    Solve(points[2].X, points[1].X, points[2].Y, true);
    Solve(points[0].Y, points[1].Y, points[0].X, false);
    Solve(points[2].Y, points[1].Y, points[2].X, false);
    printf(&quot;%d\n&quot;, (int)S.size());
    for (auto i : S) {
        printf(&quot;%d %d\n&quot;, i.first, i.second);
    }
    return 0;
}
</code></pre>
<h1 id="D-Minimum-Diameter-Tree"><a href="#D-Minimum-Diameter-Tree" class="headerlink" title="D. Minimum Diameter Tree"></a>D. Minimum Diameter Tree</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description:"></a>Description:</h2><p>You are given a tree (an undirected connected graph without cycles) and an integer $s$.<br>Vanya wants to put weights on all edges of the tree so that all weights are non-negative real numbers and their sum is $s$. At the same time, he wants to make the diameter of the tree as small as possible.<br>Let’s define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree. In other words, the diameter of a weighed tree is the length of the longest simple path in the tree, where length of a path is equal to the sum of weights over all edges in the path.<br>Find the minimum possible diameter that Vanya can get.</p>
<h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input:"></a>Input:</h2><p>The first line contains two integer numbers $n$ and $s$ ($2 \leq n \leq 10^5$, $1 \leq s \leq 10^9$) — the number of vertices in the tree and the sum of edge weights.<br>Each of the following $n−1$ lines contains two space-separated integer numbers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the indexes of vertices connected by an edge. The edges are undirected.<br>It is guaranteed that the given edges form a tree.</p>
<h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output:"></a>Output:</h2><p>Print the minimum diameter of the tree that Vanya can get by placing some non-negative real weights on its edges with the sum equal to $s$.<br>Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.<br>Formally, let your answer be $a$, and the jury’s answer be $b$. Your answer is considered correct if $\frac {|a-b|} {max(1, b)} \leq 10^{-6}$.</p>
<h2 id="Sample-Input-8"><a href="#Sample-Input-8" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>4 3<br>1 2<br>1 3<br>1 4</p>
<h2 id="Sample-Output-8"><a href="#Sample-Output-8" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>2.000000000000000000</p>
<h2 id="Sample-Input-9"><a href="#Sample-Input-9" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>6 1<br>2 1<br>2 3<br>2 5<br>5 4<br>5 6</p>
<h2 id="Sample-Output-9"><a href="#Sample-Output-9" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>0.500000000000000000</p>
<h2 id="Sample-Input-10"><a href="#Sample-Input-10" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5 5<br>1 2<br>2 3<br>3 4<br>3 5</p>
<h2 id="Sample-Output-10"><a href="#Sample-Output-10" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>3.333333333333333333</p>
<h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1085/problem/D" target="_blank" rel="noopener">题目链接</a></h3><p>分配权值使树上直径权值之和最小。</p>
<p>权值只用平分在树叶的边上即可，最后结果即为平分值的二倍（仅有两个顶点一条边的树同样成立）。</p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e5 + 5;

int N, S;
int Cnt[maxn];
int Ans;

int main(int argc, char *argv[]) {
    scanf(&quot;%d%d&quot;, &amp;N, &amp;S);
    memset(Cnt, 0, sizeof(Cnt));
    for (int i = 1, U, V; i &lt; N; ++i) {
        scanf(&quot;%d%d&quot;, &amp;U, &amp;V);
        Cnt[U]++;
        Cnt[V]++;
    }
    for (int i = 1; i &lt;= N; ++i) {
        if (Cnt[i] == 1) {
            Ans++;
        }
    }
    printf(&quot;%.18lf\n&quot;, (double)S / (double)(Ans) * 2.0);
    return 0;
}
</code></pre>

  </div>
</article>
    </main>
    <footer id="footer">
  <p id="footer-info">
    <a href="https://hexo.io/zh-cn/" id="footer-hexo">Hexo</a>
    Theme
    <a href="" id="footer-theme">&hearts;Sally&hearts;</a>
    by
    <a href="https://tony5t4rk.github.io/" id="theme-author">Tony5t4rk</a>
  </p>
</footer>
  </body>
</html>