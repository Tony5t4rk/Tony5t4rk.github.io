<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">

  <!-- font-family -->
  <link href="https://fonts.googleapis.com/css?family=Pacifico" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">

  <!-- Highlight.js -->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/solarized-light.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- jquery -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.slim.min.js"></script>

  <title>Tony5t4rk&#39;s Blog</title>
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <link rel="stylesheet" href="/css/sally.css">
	
    <link rel="shortcut icon" href="/img/favicon.png">
  
</head>

  <body>
    <header id="header">
  <div id="site-title">
    <a href="http://tony5t4rk.github.io" id="logo">
      <img id="site-logo" src="/img/blog-logo.png">
      <p>Tony5t4rk&#39;s Blog</p>
    </a>
  </div>
  <nav id="navbar">
    <ul id="menu">
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">
            Archives
          </a>
        </li>
      
    </ul>
  </nav>
</header>
    <div id="side">
  <div id="search">
    <img id="search-logo" src="/img/search.png">
    <input type="text" id="search-input" placeholder=" search">
  </div>

  <div id="author-info">
    <img id="info-logo" src="/img/avatar.png">
    <p id="info-author">Tony5t4rk</p>
    <div id="social">
      
        <div class="social-item">
          <a href="https://github.com/Tony5t4rk" class="social-item-link">
            <img class="social-img" src="/img/Github.png">
            <p class="social-item-name">Github</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="https://www.zhihu.com/people/ru-guo-you-meng-49" class="social-item-link">
            <img class="social-img" src="/img/知乎.png">
            <p class="social-item-name">知乎</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="mailto:tony5t4rk@qq.com" class="social-item-link">
            <img class="social-img" src="/img/Email.png">
            <p class="social-item-name">Email</p>
          </a>
        </div>
      
        <div class="social-item">
          <a href="https://blog.csdn.net/Tony5t4rk" class="social-item-link">
            <img class="social-img" src="/img/CSDN.png">
            <p class="social-item-name">CSDN</p>
          </a>
        </div>
      
    </div>
  </div>

  <div id="friend">
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/henu_jizhideqingwa" class="friend-item-link">
          <p class="friend-item-name">jizhideqingwa</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/henuyh" class="friend-item-link">
          <p class="friend-item-name">yh</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://www.lusquare.top/" class="friend-item-link">
          <p class="friend-item-name">lusquare</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/ordinarv" class="friend-item-link">
          <p class="friend-item-name">ordinarv</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://raindecloud.top/" class="friend-item-link">
          <p class="friend-item-name">raindecloud</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="http://47.106.254.106/" class="friend-item-link">
          <p class="friend-item-name">cyt</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://euzmin.github.io/" class="friend-item-link">
          <p class="friend-item-name">zmin</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/qq_41199327" class="friend-item-link">
          <p class="friend-item-name">mmc</p>
        </a>
      </div>
    
      <div class="friend-item">
        <a href="https://blog.csdn.net/qq_40482358" class="friend-item-link">
          <p class="friend-item-name">wxj</p>
        </a>
      </div>
    
  </div>

  <div id="site-info">
  </div>
</div>

    <main id="main">
      <article id="post">
  <div class="post-title">
    <h2 class="title">Codeforces Round #529 (Div. 3)</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2018-12-28</span>
  </div>
  <div class="post-content">
    <h1 id="A-Repeating-Cipher"><a href="#A-Repeating-Cipher" class="headerlink" title="A. Repeating Cipher"></a>A. Repeating Cipher</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h2><p>Polycarp loves ciphers. He has invented his own cipher called repeating.<br>Repeating cipher is used for strings. To encrypt the string $s=s_{1}s_{2} \dots s_{m}$ ($1 \le m \le 10$), Polycarp uses the following algorithm:</p>
<ul>
<li>he writes down $s_1$ ones,</li>
<li>he writes down $s_2$ twice,</li>
<li>he writes down $s_3$ three times,  …  he writes down $s_m$ $m$ times.</li>
</ul>
<p>For example, if $s$=”bab” the process is: “b” $\to$ “baa” $\to$ “baabbb”. So the encrypted $s$=”bab” is “baabbb”.</p>
<p>Given string $t$ — the result of encryption of some string $s$. Your task is to decrypt it, i. e. find the string $s$.</p>
<a id="more"></a>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input:"></a>Input:</h2><p>The first line contains integer $n$ ($1 \le n \le 55$) — the length of the encrypted string. The second line of the input contains $t$ — the result of encryption of some string $s$. It contains only lowercase Latin letters. The length of $t$ is exactly $n$.<br>It is guaranteed that the answer to the test exists.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h2><p>Print such string $s$ that after encryption it equals $t$.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>6<br>baabbb</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>bab</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>10<br>ooopppssss</p>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>oops</p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>1<br>z</p>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>z</p>
<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1095/problem/A" target="_blank" rel="noopener">题目链接</a></h3><p>将字符串第 $i$ 个字符写 $i$ 次构成新字符串，求原字符串。</p>
<p>每 $i$ 个字符提取一个字符即可。</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

int T;
int Cnt;
string Str;
string Ans;

int main(int argc, char *argv[]) {
    cin &gt;&gt; T &gt;&gt; Str;
    Cnt = 1;
    for (int i = 1; Cnt &lt;= T; ++i) {
        Ans += Str[Cnt - 1];
        Cnt += i;
    }
    cout &lt;&lt; Ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<h1 id="B-Array-Stabilization"><a href="#B-Array-Stabilization" class="headerlink" title="B. Array Stabilization"></a>B. Array Stabilization</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description:"></a>Description:</h2><p>You are given an array $a$ consisting of $n$ integer numbers.<br>Let instability of the array be the following value: $\max\limits_{i = 1}^{n} a_i - \min\limits_{i = 1}^{n} a_i$.<br>You have to remove exactly one element from this array to minimize instability of the resulting $(n-1)$-elements array. Your task is to calculate the minimum possible instability.</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input:"></a>Input:</h2><p>The first line of the input contains one integer $n$ ($2 \le n \le 10^5$) — the number of elements in the array $a$.<br>The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^5$) — elements of the array $a$.</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output:"></a>Output:</h2><p>Print one integer — the minimum possible instability of the array if you have to remove exactly one element from the array $a$.</p>
<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>4<br>1 3 3 7</p>
<h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>2</p>
<h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>2<br>1 100000</p>
<h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>0</p>
<h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1095/problem/B" target="_blank" rel="noopener">题目链接</a></h3><p>在数列中删去一个数字使数列最大值与最小值之差最小。</p>
<p>显然删去最大值或者最小值。</p>
<h2 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e5 + 5;

int N;
int Ans;
int Array[maxn];

int main(int argc, char *argv[]) {
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 1; i &lt;= N; ++i) {
        scanf(&quot;%d&quot;, &amp;Array[i]);
    }
    sort(Array + 1, Array + N + 1);
    Ans = min(Array[N - 1] - Array[1], Array[N] - Array[2]);
    printf(&quot;%d\n&quot;, Ans);
    return 0;
}
</code></pre>
<h1 id="C-Powers-Of-Two"><a href="#C-Powers-Of-Two" class="headerlink" title="C. Powers Of Two"></a>C. Powers Of Two</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description:"></a>Description:</h2><p>A positive integer $x$ is called a power of two if it can be represented as $x = 2^y$, where $y$ is a non-negative integer. So, the powers of two are $1, 2, 4, 8, 16, \dots$.<br>You are given two positive integers $n$ and $k$. Your task is to represent $n$ as the sum of exactly $k$ powers of two.</p>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input:"></a>Input:</h2><p>The only line of the input contains two integers $n$ and $k$ ($1 \le n \le 10^9$, $1 \le k \le 2 \cdot 10^5$).</p>
<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output:"></a>Output:</h2><p>If it is impossible to represent $n$ as the sum of $k$ powers of two, print NO.<br>Otherwise, print YES, and then print $k$ positive integers $b_1, b_2, \dots, b_k$ such that each of $b_i$ is a power of two, and $\sum \limits_{i = 1}^{k} b_i = n$. If there are multiple answers, you may print any of them.</p>
<h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>9 4</p>
<h2 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>YES<br>1 2 2 4 </p>
<h2 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>8 1</p>
<h2 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>YES<br>8 </p>
<h2 id="Sample-Input-7"><a href="#Sample-Input-7" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5 1</p>
<h2 id="Sample-Output-7"><a href="#Sample-Output-7" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>NO</p>
<h2 id="Sample-Input-8"><a href="#Sample-Input-8" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3 7</p>
<h2 id="Sample-Output-8"><a href="#Sample-Output-8" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>NO</p>
<h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1095/problem/C" target="_blank" rel="noopener">题目链接</a></h3><p>用 $k$ 个 $2^{x}$ 数组成和为 $n$ ，输出 $k$  个数。</p>
<p>对的 $2^{x}(x\in [0,30])$ 打表，之后在表中对 $n$ 从第一个小于等于 $2^{x}$ 开始依次递减查找凑数即可。</p>
<h2 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

long long N, K;

long long Data[31];
vector&lt;long long&gt; Ans;

int main(int argc, char *argv[]) {
    for (int i = 0; i &lt; 31; ++i) {
        Data[i] = (1 &lt;&lt; i);
    }
    scanf(&quot;%lld%lld&quot;, &amp;N, &amp;K);
    if (K &gt; N) {
        printf(&quot;NO\n&quot;);
        return 0;
    }
    else if (K == N) {
        printf(&quot;YES\n&quot;);
        for (int i = 1; i &lt;= N; ++i) {
            printf(&quot;1 &quot;);
        }
        printf(&quot;\n&quot;);
        return 0;
    }
    int Index = lower_bound(Data, Data + 31, N) - Data;
    Ans.clear();
    for (int i = Index; i &gt;= 0; --i) {
        while (N - Data[i] &gt;= K - 1 &amp;&amp; K &gt;= 1 &amp;&amp; N &gt; 0) {
            Ans.push_back(Data[i]);
            N -= Data[i];
            K--;
        }
        if (N == 0 || N &lt; K || K == 0) {
            break;
        }
    }
    if (N == 0 &amp;&amp; K == 0) {
        printf(&quot;YES\n&quot;);
        sort(Ans.begin(), Ans.end());
        for (auto i : Ans) {
            printf(&quot;%lld &quot;, i);
        }
    }
    else {
        printf(&quot;NO&quot;);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<h1 id="D-Circular-Dance"><a href="#D-Circular-Dance" class="headerlink" title="D. Circular Dance"></a>D. Circular Dance</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description:"></a>Description:</h2><p>There are $n$ kids, numbered from $1$ to $n$, dancing in a circle around the Christmas tree. Let’s enumerate them in a clockwise direction as $p_1$, $p_2$, …, $p_n$ (all these numbers are from $1$ to $n$ and are distinct, so $p$ is a permutation). Let the next kid for a kid $p_i$ be kid $p_{i + 1}$ if $i &lt; n$ and $p_1$ otherwise. After the dance, each kid remembered two kids: the next kid (let’s call him $x$) and the next kid for $x$. Each kid told you which kids he/she remembered: the kid $i$ remembered kids $a_{i, 1}$ and $a_{i, 2}$. However, the order of $a_{i, 1}$ and $a_{i, 2}$ can differ from their order in the circle.<br>  Example: 5 kids in a circle, $p=[3, 2, 4, 1, 5]$ (or any cyclic shift). The information kids remembered is: $a_{1,1}=3$, $a_{1,2}=5$; $a_{2,1}=1$, $a_{2,2}=4$; $a_{3,1}=2$, $a_{3,2}=4$; $a_{4,1}=1$, $a_{4,2}=5$; $a_{5,1}=2$, $a_{5,2}=3$. You have to restore the order of the kids in the circle using this information. If there are several answers, you may print any. It is guaranteed that at least one solution exists.<br>If you are Python programmer, consider using PyPy instead of Python when you submit your code.</p>
<h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input:"></a>Input:</h2><p>The first line of the input contains one integer $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of the kids.<br>The next $n$ lines contain $2$ integers each. The $i$-th line contains two integers $a_{i, 1}$ and $a_{i, 2}$ ($1 \le a_{i, 1}, a_{i, 2} \le n, a_{i, 1} \ne a_{i, 2}$) — the kids the $i$-th kid remembered, given in arbitrary order.</p>
<h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output:"></a>Output:</h2><p>Print $n$ integers $p_1$, $p_2$, …, $p_n$ — permutation of integers from $1$ to $n$, which corresponds to the order of kids in the circle. If there are several answers, you may print any (for example, it doesn’t matter which kid is the first in the circle). It is guaranteed that at least one solution exists.</p>
<h2 id="Sample-Input-9"><a href="#Sample-Input-9" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5<br>3 5<br>1 4<br>2 4<br>1 5<br>2 3</p>
<h2 id="Sample-Output-9"><a href="#Sample-Output-9" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>3 2 4 1 5 </p>
<h2 id="Sample-Input-10"><a href="#Sample-Input-10" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3<br>2 3<br>3 1<br>1 2</p>
<h2 id="Sample-Output-10"><a href="#Sample-Output-10" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>3 1 2 </p>
<h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1095/problem/D" target="_blank" rel="noopener">题目链接</a></h3><p>一个环有 $n$ 个节点，给出每个节点的后面两个节点（无序），求环。</p>
<p>从第一个节点开始找，只要确定前两个节点，则后续节点即可依次递推出。</p>
<h2 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 2e5 + 5;

int N;
int Next[maxn][2];
vector&lt;int&gt; Ans;

int main(int argc, char *argv[]) {
    scanf(&quot;%d&quot;, &amp;N);
    for (int i = 1; i &lt;= N; ++i) {
        scanf(&quot;%d%d&quot;, &amp;Next[i][0], &amp;Next[i][1]);
    }
    Ans.push_back(1);
    int First = Next[1][0];
    if (Next[1][1] == Next[First][0] || Next[1][1] == Next[First][1]) {
        Ans.push_back(Next[1][0]);
    }
    else {
        Ans.push_back(Next[1][1]);
    }
    for (int i = 2; i &lt; N; ++i) {
        int Size = (int)Ans.size();
        int Temp = Ans[Size - 2];
        if (Ans.back() == Next[Temp][0]) {
            Ans.push_back(Next[Temp][1]);
        }
        else {
            Ans.push_back(Next[Temp][0]);
        }
    }
    for (auto i : Ans) {
        printf(&quot;%d &quot;, i);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<h1 id="E-Almost-Regular-Bracket-Sequence"><a href="#E-Almost-Regular-Bracket-Sequence" class="headerlink" title="E. Almost Regular Bracket Sequence"></a>E. Almost Regular Bracket Sequence</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description:"></a>Description:</h2><p>You are given a bracket sequence $s$ consisting of $n$ opening ‘(‘ and closing ‘)’ brackets.<br>A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ‘1’ and ‘+’ between the original characters of the sequence. For example, bracket sequences “()()”, “(())” are regular (the resulting expressions are: “(1)+(1)”, “((1+1)+1)”), and “)(“ and “(“ are not.<br>You can change the type of some bracket $s_i$. It means that if $s_i = $ ‘)’ then you can change it to ‘(‘ and vice versa.<br>Your task is to calculate the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.</p>
<h2 id="Input-4"><a href="#Input-4" class="headerlink" title="Input:"></a>Input:</h2><p>The first line of the input contains one integer $n$ ($1 \le n \le 10^6$) — the length of the bracket sequence.<br>The second line of the input contains the string $s$ consisting of $n$ opening ‘(‘ and closing ‘)’ brackets.</p>
<h2 id="Output-4"><a href="#Output-4" class="headerlink" title="Output:"></a>Output:</h2><p>Print one integer — the number of positions $i$ such that if you change the type of the $i$-th bracket, then the resulting bracket sequence becomes regular.</p>
<h2 id="Sample-Input-11"><a href="#Sample-Input-11" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>6<br>(((())</p>
<h2 id="Sample-Output-11"><a href="#Sample-Output-11" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>3</p>
<h2 id="Sample-Input-12"><a href="#Sample-Input-12" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>6<br>()()()</p>
<h2 id="Sample-Output-12"><a href="#Sample-Output-12" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>0</p>
<h2 id="Sample-Input-13"><a href="#Sample-Input-13" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>1<br>)</p>
<h2 id="Sample-Output-13"><a href="#Sample-Output-13" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>0</p>
<h2 id="Sample-Input-14"><a href="#Sample-Input-14" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>8<br>)))(((((</p>
<h2 id="Sample-Output-14"><a href="#Sample-Output-14" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>0</p>
<h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1095/problem/E" target="_blank" rel="noopener">题目链接</a></h3><p>给出一个含有 $n$  个字符（字符仅含 ‘(‘、’)’）的字符串，求字符串中有多少个括号改变之后字符串括号完全匹配。</p>
<p>之前做括号匹配问题只知道用栈的模拟做法，但是显然用在这道题上会超时，所以赛后学习官方题解才大开眼界，括号匹配用前缀后缀和做更方便快捷。</p>
<p>首先正序计算字符串前缀和（左括号+1，右括号-1）与前缀和标记，之后倒序计算字符串后缀和（左括号-1，右括号+1）与后缀和标记，枚举字符串每个位置通过前后缀和判断此位置括号改变后整体字符串是否能够达到括号匹配。</p>
<h2 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e6 + 5;

int N;
char Str[maxn];
int Prefix[maxn];
int Suffix[maxn];
bool PreFlag[maxn], SufFlag[maxn];
int Ans;

int main(int argc, char *argv[]) {
    scanf(&quot;%d%s&quot;, &amp;N, Str + 1);
    PreFlag[0] = true;
    for (int i = 1; i &lt;= N; ++i) {
        Prefix[i] = Prefix[i - 1] + (Str[i] == &#39;(&#39; ? 1 : -1);
        PreFlag[i] = PreFlag[i - 1] &amp; (Prefix[i] &gt;= 0);
    }
    SufFlag[N + 1] = true;
    for (int i = N; i &gt;= 1; --i) {
        Suffix[i] = Suffix[i + 1] + (Str[i] == &#39;)&#39; ? 1 : -1);
        SufFlag[i] = SufFlag[i + 1] &amp; (Suffix[i] &gt;= 0);
    }
    for (int i = 1; i &lt;= N; ++i) {
        if (!PreFlag[i - 1] || !SufFlag[i + 1]) {
            continue;
        }
        if (Str[i] == &#39;(&#39;) {
            // 若左括号1~i-1区间内字符串中左括号多于右括号且前缀和-后缀和=1（左边区间左括号减右括号比右边区间右括号减左括号多一个）则此位置左括号可以改变为右括号
            if (Prefix[i - 1] &gt; 0 &amp;&amp; Prefix[i - 1] - Suffix[i + 1] == 1) {
                ++Ans;
            }
        }
        else {
            // 同理可改变右括号为左括号
            if (Suffix[i + 1] - Prefix[i - 1] == 1) {
                ++Ans;
            }
        }
    }
    printf(&quot;%d\n&quot;, Ans);
    return 0;
}
</code></pre>
<h1 id="F-Make-It-Connected"><a href="#F-Make-It-Connected" class="headerlink" title="F. Make It Connected"></a>F. Make It Connected</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description:"></a>Description:</h2><p>You are given an undirected graph consisting of $n$ vertices. A number is written on each vertex; the number on vertex $i$ is $a_i$. Initially there are no edges in the graph.<br>You may add some edges to this graph, but you have to pay for them. The cost of adding an edge between vertices $x$ and $y$ is $a_x + a_y$ coins. There are also $m$ special offers, each of them is denoted by three numbers $x$, $y$ and $w$, and means that you can add an edge connecting vertices $x$ and $y$ and pay $w$ coins for it. You don’t have to use special offers: if there is a pair of vertices $x$ and $y$ that has a special offer associated with it, you still may connect these two vertices paying $a_x + a_y$ coins for it.<br>What is the minimum number of coins you have to spend to make the graph connected? Recall that a graph is connected if it’s possible to get from any vertex to any other vertex using only the edges belonging to this graph.</p>
<h2 id="Input-5"><a href="#Input-5" class="headerlink" title="Input:"></a>Input:</h2><p>The first line contains two integers $n$ and $m$ ($1 \le n \le 2 \cdot 10^5$, $0 \le m \le 2 \cdot 10^5$) — the number of vertices in the graph and the number of special offers, respectively.<br>The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^{12}$) — the numbers written on the vertices.<br>Then $m$ lines follow, each containing three integers $x$, $y$ and $w$ ($1 \le x, y \le n$, $1 \le w \le 10^{12}$, $x \ne y$) denoting a special offer: you may add an edge connecting vertex $x$ and vertex $y$, and this edge will cost $w$ coins.</p>
<h2 id="Output-5"><a href="#Output-5" class="headerlink" title="Output:"></a>Output:</h2><p>Print one integer — the minimum number of coins you have to pay to make the graph connected.</p>
<h2 id="Sample-Input-15"><a href="#Sample-Input-15" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>3 2<br>1 3 3<br>2 3 5<br>2 1 1</p>
<h2 id="Sample-Output-15"><a href="#Sample-Output-15" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>5</p>
<h2 id="Sample-Input-16"><a href="#Sample-Input-16" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>4 0<br>1 3 3 7</p>
<h2 id="Sample-Output-16"><a href="#Sample-Output-16" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>16</p>
<h2 id="Sample-Input-17"><a href="#Sample-Input-17" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5 4<br>1 2 3 4 5<br>1 2 8<br>1 3 10<br>1 4 7<br>1 5 15</p>
<h2 id="Sample-Output-17"><a href="#Sample-Output-17" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>18</p>
<h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a><a href="http://codeforces.com/contest/1095/problem/F" target="_blank" rel="noopener">题目链接</a></h3><p>$n$ 个顶点，每个顶点有一个权值，将两顶点相连的花费为两顶点权值之和，$m$ 条边，每条边用 $w$ 花费进行相连（当然也可以用两顶点权值之和），求将 $n$ 个顶点连接为连通图的最小花费。</p>
<p>显然此题是求最小生成树，所以如何建边就是解此题的核心问题，若将任意两顶点都建边（权值为两顶点权值之和）无法存储，所以仅需将 $n$ 个顶点与权值最小的顶点相连建边即可（花费必然优于与其它顶点相连），剩下 $m$ 条边单独建边，用Kruskal/Prim求出MST即可。</p>
<h2 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码:"></a>AC代码:</h2><pre><code class="cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int INF = 0x3f3f3f3f;
const int maxn = 2e5 + 5;

struct Edge {
    int U, V;
    long long Dis;

    bool operator &lt; (const Edge &amp;B) const {
        return Dis &lt; B.Dis;
    }
};

int N, M;
int Tot;
int Pre[maxn];
Edge edges[maxn &lt;&lt; 4];

void Init() {
    for (int i = 0; i &lt;= N; ++i) {
        Pre[i] = i;
    }
}

int Find(int X) {
    int R = X;
    while (Pre[R] != R) {
        R = Pre[R];
    }
    int I = X, J;
    while (I != R) {
        J = Pre[I];
        Pre[I] = R;
        I = J;
    }
    return R;
}

void Join(int X, int Y) {
    int XX = Find(X);
    int YY = Find(Y);
    if (XX != YY) {
        Pre[XX] = YY;
    }
}

long long Kruskal() {
    sort(edges, edges + Tot);
    Init();
    long long Res = 0;
    for (int i = 0; i &lt; Tot; ++i) {
        Edge Temp = edges[i];
        if (Find(Temp.U) != Find(Temp.V)) {
            Join(Temp.U, Temp.V);
            Res += Temp.Dis;
        }
    }
    return Res;
}

long long Vertex[maxn];
int Min;

int main(int argc, char *argv[]) {
    scanf(&quot;%d%d&quot;, &amp;N, &amp;M);
    Min = 1;
    for (int i = 1; i &lt;= N; ++i) {
        scanf(&quot;%lld&quot;, &amp;Vertex[i]);
        if (Vertex[i] &lt; Vertex[Min]) {
            Min = i;
        }
    }
    Tot = 0;
    for (int i = 1; i &lt;= N; ++i) {
        edges[Tot++] = Edge {i, Min, Vertex[i] + Vertex[Min]};
    }
    for (int i = 1, U, V; i &lt;= M; ++i) {
        long long Coin;
        scanf(&quot;%d%d%lld&quot;, &amp;U, &amp;V, &amp;Coin);
        edges[Tot++] = Edge{U, V, Coin};
    }
    printf(&quot;%lld\n&quot;, Kruskal());
    return 0;
}
</code></pre>

  </div>
</article>
    </main>
    <footer id="footer">
  <p id="footer-info">
    <a href="https://hexo.io/zh-cn/" id="footer-hexo">Hexo</a>
    Theme
    <a href="" id="footer-theme">&hearts;Sally&hearts;</a>
    by
    <a href="https://tony5t4rk.github.io/" id="theme-author">Tony5t4rk</a>
  </p>
</footer>
  </body>
</html>